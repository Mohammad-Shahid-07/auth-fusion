{
  "name": "Prisma.user.actions",

  "files": [
    {
      "name": "user.actions.ts",
      "imports": "",
      "content": "\"use server\";\r\nimport { database } from \"@/lib/database\";\r\nimport { currentUser } from \"@/lib/utils/currentUser\";\r\nimport { revalidatePath } from \"next/cache\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport {\r\n  DeleteAccountSchema,\r\n  SetPasswordSchema,\r\n  UpdateUserSchema,\r\n} from \"@/validations\";\r\nimport { z } from \"zod\";\r\ntype UpdateUserImageProps = {\r\n  image: string;\r\n  path: string;\r\n};\r\nexport async function updateUserImage(params: UpdateUserImageProps) {\r\n  try {\r\n    const { image, path } = params;\r\n\r\n    const userSession = await currentUser();\r\n    if (!userSession) {\r\n      return null;\r\n    }\r\n\r\n    const user = await database.user.findFirst({\r\n      where: {\r\n        email: userSession.email,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new Error(\"User not found\");\r\n    }\r\n\r\n    await database.user.update({\r\n      where: {\r\n        id: user.id,\r\n      },\r\n      data: {\r\n        image: image,\r\n      },\r\n    });\r\n\r\n    userSession.image = image;\r\n\r\n    revalidatePath(path);\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function updateUserNameUser(\r\n  values: z.infer<typeof UpdateUserSchema>,\r\n  pathname: string,\r\n) {\r\n  try {\r\n    const validatedFields = UpdateUserSchema.safeParse(values);\r\n    if (!validatedFields.success) {\r\n      return { error: \"Something went wrong\" };\r\n    }\r\n    const { name } = values;\r\n    const userSession = await currentUser();\r\n    if (!userSession) {\r\n      return null;\r\n    }\r\n\r\n    const updatedUser = await database.user.update({\r\n      where: {\r\n        email: userSession.email!,\r\n      },\r\n      data: {\r\n        name: name,\r\n      },\r\n    });\r\n\r\n    if (!updatedUser) {\r\n      return { error: \"User not found\" };\r\n    }\r\n\r\n    userSession.name = updatedUser.name;\r\n\r\n    revalidatePath(pathname);\r\n\r\n    return { success: \"User updated\" };\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function setNewPassword(values: z.infer<typeof SetPasswordSchema>,) {\r\n  try {\r\n     const validatedFields = SetPasswordSchema.safeParse(values);\r\n    if (!validatedFields.success) {\r\n      return { error: \"Something went wrong\" };\r\n    }\r\n    const { newPassword } = values;\r\n    const user = await currentUser();\r\n    if (!user) {\r\n      return { error: \"User Not Found\" };\r\n    }\r\n    const dbUser = await database.user.findFirst({\r\n      where: {\r\n        email: user.email,\r\n      },\r\n    });\r\n\r\n    if (!dbUser) {\r\n      return { error: \"User Not Found\" };\r\n    }\r\n\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    await database.user.update({\r\n      where: {\r\n        email: dbUser.email,\r\n      },\r\n      data: {\r\n        password: hashedPassword,\r\n      },\r\n    });\r\n\r\n    revalidatePath(path);\r\n\r\n    return {\r\n      success:\r\n        \"Password Created. Now you can login with your email and new password.\",\r\n    };\r\n  } catch (error) {\r\n    console.error(error);\r\n    return { error: \"Something Went Wrong\" };\r\n  }\r\n}\r\n\r\nexport async function changePassword(values: z.infer<typeof SetPasswordSchema>) {\r\n  try {\r\n     const validatedFields = SetPasswordSchema.safeParse(values);\r\n    if (!validatedFields.success) {\r\n      return { error: \"Something went wrong\" };\r\n    }\r\n    const { oldPassword, newPassword } = values;\r\n    if (!oldPassword) return { error: \"Please enter your old password\" };\r\n     const user = await currentUser();\r\n    if (!user) {\r\n      return { error: \"User Not Found\" };\r\n    }\r\n    const dbUser = await database.user.findFirst({\r\n      where: {\r\n        email: user.email,\r\n      },\r\n    });\r\n\r\n    if (!dbUser) {\r\n      return { error: \"User Not Found\" };\r\n    }\r\n\r\n    const isMatch = await bcrypt.compare(oldPassword, dbUser.password!);\r\n    if (!isMatch) {\r\n      return { error: \"Old password is incorrect\" };\r\n    }\r\n\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    await database.user.update({\r\n      where: {\r\n        email: dbUser.email,\r\n      },\r\n      data: {\r\n        password: hashedPassword,\r\n      },\r\n    });\r\n\r\n    revalidatePath(path);\r\n\r\n    return { success: \"Password Updated\" };\r\n  } catch (error) {\r\n    console.error(error);\r\n    return { error: \"Something Went Wrong\" };\r\n  }\r\n}\r\nexport async function deleteUser(values: z.infer<typeof DeleteAccountSchema) {\r\n  try {\r\n    const userSession = await currentUser();\r\n    if (!userSession) {\r\n      return null;\r\n    }\r\n    \r\n    const validatedFields = DeleteAccountSchema.safeParse(values);\r\n    if (!validatedFields.success) {\r\n      console.log(validatedFields);\r\n      return { error: \"Something went wrong\" };\r\n    }\r\n\r\n    const { email, password } = values;\r\n    \r\n    const user = await prisma.user.findUnique({\r\n      where: { email: userSession.email },\r\n    });\r\n\r\n\r\n    if (user.password) {\r\n      const isMatch = await bcrypt.compare(password!, user.password);\r\n      if (!isMatch) {\r\n        return { error: \"Password is incorrect\" };\r\n      }\r\n      await prisma.user.delete({\r\n        where: { email: user.email },\r\n      });\r\n    } else {\r\n        if (!user || user.email !== email) {\r\n        return { error: \"Email does not exist in our database\" };\r\n        }\r\n      await prisma.user.delete({\r\n        where: { email },\r\n      });\r\n    }\r\n\r\n    return { success: \"User deleted successfully\" };\r\n  } catch (error) {\r\n    console.log(error);\r\n    return { error: \"Something went wrong\" };\r\n  }\r\n//[TwoFactorToggleServerAction]\r\n"
    }
  ],
  "type": "actions"
}
