{
  "name": "credentials-base",
  "imports": "import { LoginSchema, NewPasswordSchema, RegisterSchema, ResetSchema } from \"@/validations\"; import * as z from \"zod\"; import bcrypt from \"bcryptjs\"; import User from \"@/models/user.model\"; import { connectToDatabase } from \"@/lib/db\"; import EmailVerification from \"@/models/email_verify.model\"; import { v4 as uuidv4 } from \"uuid\"; import { sendResetEmail, sendTwoFactorEmail, sendVerificationEmail } from \"../mail\"; import ForgotPassword from \"@/models/forgot_pass.model\";",
  "content": "export async function getVerificationTokenByEmail(email: string) {\n  try {\n    connectToDatabase();\n    const Verificationtoken = await EmailVerification.findOne({ email });\n    if (!Verificationtoken) {\n      return { error: \"Token not found\" };\n    }\n    return Verificationtoken;\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport async function getVerificationTokenByToken(token: string) {\n  try {\n    connectToDatabase();\n    const Verificationtoken = await EmailVerification.findOne({ token });\n    if (!Verificationtoken) {\n      return { error: \"Token not found\" };\n    }\n    return Verificationtoken;\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport const geterateVerificationToken = async (email: string) => {\n  try {\n    connectToDatabase();\n    const token = uuidv4();\n    const expiresAt = new Date(new Date().getTime() + 1 * 60 * 60 * 1000);\n    const existingToken = await EmailVerification.findOneAndDelete({ email });\n\n    const newVerificationToken = new EmailVerification({\n      email,\n      token,\n      expiresAt,\n    });\n    await newVerificationToken.save();\n    return newVerificationToken;\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport async function verifyToken(token: string) {\n  try {\n    connectToDatabase();\n    const existingToken = await EmailVerification.findOne({ token });\n\n    if (!existingToken) {\n      return { error: \"Token not found\" };\n    }\n    const hasExpired = new Date().getTime() > existingToken.expiresAt.getTime();\n    if (hasExpired) {\n      await existingToken.deleteOne();\n      return { error: \"Token expired\" };\n    }\n    const { email } = existingToken;\n    const user = await User.findOne({ email });\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n\n    user.emailVerified = new Date();\n    user.email = email;\n    await user.save();\n    await existingToken.deleteOne();\n    return { success: \"Email Verified!\" };\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport const generatePasswordResetToken = async (email: string) => {\n  try {\n    connectToDatabase();\n    const token = uuidv4();\n    const expiresAt = new Date(new Date().getTime() + 60 * 60 * 1000);\n    const existingToken = await ForgotPassword.findOneAndDelete({ email });\n\n    const newPasswordResetToken = new ForgotPassword({\n      email,\n      token,\n      expiresAt,\n    });\n    await newPasswordResetToken.save();\n    return newPasswordResetToken;\n  } catch (error) {\n    console.log(error);\n  }\n};\nexport async function resetPassword(values: z.infer<typeof ResetSchema>) {\n  try {\n    const validatedFields = ResetSchema.safeParse(values);\n    if (!validatedFields.success) {\n      return { error: \"Please provide a valid email\" };\n    }\n    const { email } = validatedFields.data;\n    connectToDatabase();\n    const user = await User.findOne({ email });\n    if (!user) {\n      return { error: \"User not found\" };\n    }\n    const Verificationtoken = await generatePasswordResetToken(email);\n    await sendResetEmail(Verificationtoken.email, Verificationtoken.token);\n    return { success: \"Password reset email sent\" };\n  } catch (error) {\n    return { error: \"Something went wrong\" };\n  }\n}\n\nexport async function resetPasswordWithToken(\n  values: z.infer<typeof NewPasswordSchema>,\n  token: string,\n) {\n  try {\n    const validatedFields = NewPasswordSchema.safeParse(values);\n    if (!validatedFields.success) {\n      return { error: \"Please provide a valid email\" };\n    }\n    const { password } = validatedFields.data;\n    connectToDatabase();\n\n    const existingToken = await ForgotPassword.findOne({ token });\n    if (!existingToken) {\n      return { error: \"Token not found\" };\n    }\n    const user = await User.findOne({ email: existingToken.email });\n    const hasExpired = new Date().getTime() > existingToken.expiresAt.getTime();\n    if (hasExpired) {\n      await existingToken.deleteOne();\n      return { error: \"Token expired\" };\n    }\n    const hashedPassword = await bcrypt.hash(values.password, 10);\n    user.password = hashedPassword;\n    await user.save();\n    await existingToken.deleteOne();\n    return { success: \"Password reset\" };\n  } catch (error) {\n    return { error: \"Something went wrong\" };\n  }\n}"
}
